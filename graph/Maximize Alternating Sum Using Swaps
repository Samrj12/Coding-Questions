class Solution {
public:
    struct DSU {
        vector<int> rank, par;
        DSU(int n) {
            rank.resize(n, 1);
            par.resize(n);
            for(int i = 0; i< n;i++){
                par[i] = i;
            }
        }

        int findP(int u){
            if(par[u] != u)
            return par[par[u]] = findP(par[u]);
            return u;
        }
        void unite(int u, int v){
            int pu = findP(u);
            int pv = findP(v);

            if(pv != pu){
                if(rank[pu] > rank[pv])
                {
                    rank[pu] += rank[pv];
                    par[pv] = pu;
                }else{
                    
                    rank[pv] += rank[pu];
                    par[pu] = pv;
                }
            }
        }
    };
    long long maxAlternatingSum(vector<int>& nums,
                                  vector<vector<int>>& swaps) {
        int n = nums.size();
        DSU dsu(n);
        for(auto& s : swaps){
            dsu.unite(s[0], s[1]);
        }
        unordered_map<int, multiset<int>> mp;
        for(int i=0;i<n;i++){
            int p = dsu.findP(i);
            mp[p].insert(nums[i]);
        }
        long long res = 0;
        for(int i=0;i<n;i++){
            if(i % 2){
                auto it = mp[dsu.findP(i)].begin();
                res -= *it;
                mp[dsu.findP(i)].erase(it);
            }else{
                auto it = prev(mp[dsu.findP(i)].end());
                res += *it;
                mp[dsu.findP(i)].erase(it);
            }
        }
        return res;
    }
};
